# 背景信息

```bash
[root@localhost P2P]# lspci -tv
-[0000:00]-+-00.0  Loongson Technology LLC Device 7a59
           +-04.0  Loongson Technology LLC OHCI USB Controller
           +-04.1  Loongson Technology LLC EHCI USB Controller
           +-05.0  Loongson Technology LLC OHCI USB Controller
           +-05.1  Loongson Technology LLC EHCI USB Controller
           +-07.0  Loongson Technology LLC HDA (High Definition Audio) Controller
           +-08.0  Loongson Technology LLC Device 7a18
           +-09.0-[03]--
           +-0a.0-[04]----00.0  Loongson Technology LLC Device 1a05
           +-0b.0-[05]----00.0  Device 1f0a:6801
           +-0c.0-[06]----00.0  Device 1f0a:6801
           +-0d.0-[07]--
           +-0f.0-[08]--
           +-10.0-[09]--
           +-16.0  Loongson Technology LLC Device 7a1b
           +-19.0  Loongson Technology LLC Device 7a34
           +-1c.0-[0a-0c]--+-00.0-[0b]----00.0  Device 2006:0100
           |               \-01.0-[0c]--
           +-1d.0  Loongson Technology LLC Device 3c0f
           \-1e.0-[0d-11]--+-00.0-[0e]--
                           +-01.0-[0f]----00.0  Device 2006:0100
                           +-02.0-[10]--
                           +-03.0-[11]----00.0  YEESTOR Microelectronics Co., Ltd Device ef25
                           \-04.0  Loongson Technology LLC Device 3c0f
[root@localhost P2P]#

 
```

## PCIe 地址结构解析

### `0000:00` 的含义

PCIe 设备地址格式为：**`Domain:Bus:Device.Function`**

```bash
0000:00:1e.0
│    │  │  └─ Function (功能号): 0-7
│    │  └──── Device (设备号): 0-31  
│    └─────── Bus (总线号): 0-255
└──────────── Domain (域): 0-65535
```

**`0000:00`** 表示：

- **Domain 0000**: PCIe 域 0（大多数系统只有一个域）

- **Bus 00**: 总线 0（Root Complex 所在的主总线）

**Root Complex (RC)** 始终位于 `Domain:0, Bus:0`，即 `0000:00`

### 域（Domain）的作用

- **单域系统**：大多数系统只有 Domain 0

- **多域系统** ：多 CPU、多 Root Complex 系统可能有多个域

  - 例如：`0000:00`, `0001:00` 表示两个独立的 PCIe 域

- **当前系统**：只有一个域 (`0000`)，所有设备都在 Domain 0

------

## `0f:00.0` 完整 PCIe 链路图

### 图形化表示

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Root Complex (RC)                                │
│                       Domain: 0000, Bus: 00                              │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                        ┌───────────┴───────────┐
                        │   0000:00:1e.0        │  ← Root Port
                        │   PCI Bridge [0604]   │
                        │   Loongson 3c09       │
                        └───────────┬───────────┘
                                    │
                        ┌───────────▼───────────┐
                        │    PCIe Link          │
                        │    Bus 0d (13)        │  ← Secondary Bus
                        └───────────┬───────────┘
                                    │
                        ┌───────────▼───────────┐
                        │   0000:0d:01.0        │  ← PCIe Switch
                        │   PCI Bridge [0604]   │     Downstream Port
                        │   Loongson 3c19       │
                        └───────────┬───────────┘
                                    │
                        ┌───────────▼───────────┐
                        │    PCIe Link          │
                        │    Bus 0f (15)        │  ← Tertiary Bus
                        └───────────┬───────────┘
                                    │
                        ┌───────────▼───────────┐
                        │   0000:0f:00.0        │  ← 加速卡 (终端设备)
                        │   Device 2006:0100    │
                        │   Processing accel.   │
                        └───────────────────────┘
```

### 层次结构文本表示

```
层级 0 (Root Complex):
    ├─ 0000:00:1e.0 - PCI Bridge [0604] - Root Port
    │   └─ Primary Bus: 00
    │   └─ Secondary Bus: 0d (13)
    │   └─ Subordinate Bus: 11 (17)
    │
层级 1 (PCIe Switch):
    ├─ 0000:0d:01.0 - PCI Bridge [0604] - Switch Downstream Port
    │   └─ Primary Bus: 0d (13)
    │   └─ Secondary Bus: 0f (15)
    │   └─ Subordinate Bus: 0f (15)
    │
层级 2 (End Device):
    └─ 0000:0f:00.0 - Device 2006:0100 - 加速卡
        └─ Bus: 0f (15)
        └─ Device: 00
        └─ Function: 0
```

### 详细的总线编号说明

```
总线号 (十六进制)总线号 (十进制)说明
000   Root Complex 主总线
0d    PCIe Switch 上游总线
0f   加速卡所在总线
```

------

## 完整的 PCIe 配置空间信息

### 查看完整链路的命令

bash

```bash
# 1. 查看 Root Port (00:1e.0)
lspci -vvv -s 0000:00:1e.0 | grep -E "Bus:|LnkCap|LnkSta"

# 2. 查看 PCIe Switch (0d:01.0)
lspci -vvv -s 0000:0d:01.0 | grep -E "Bus:|LnkCap|LnkSta"

# 3. 查看加速卡 (0f:00.0)
lspci -vvv -s 0000:0f:00.0 | grep -E "Bus:|LnkCap|LnkSta"
```

### 预期输出示例

```bash
# Root Port
Bus: primary=00, secondary=0d, subordinate=11
LnkCap: Speed 16GT/s, Width x16
LnkSta: Speed 16GT/s, Width x16

# PCIe Switch Downstream Port
Bus: primary=0d, secondary=0f, subordinate=0f
LnkCap: Speed 16GT/s, Width x16
LnkSta: Speed 16GT/s, Width x16

# 加速卡
LnkCap: Speed 16GT/s, Width x16
LnkSta: Speed 16GT/s, Width x16
```

------

### 完整的链路分析脚本

创建 `analyze_pcie_path.sh`:

```bash
#!/bin/bash

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

TARGET_BDF="0f:00.0"

echo -e "${GREEN}=== PCIe Path Analysis for $TARGET_BDF ===${NC}"
echo ""

# 函数：获取设备的上游桥接
get_upstream_bridge() {
    local bdf=$1
    local bus=$(echo $bdf | cut -d: -f1)
    
    # 查找连接到这个总线的桥接
    lspci -nn | grep "\[0604\]" | while read line; do
        bridge_bdf=$(echo $line | awk '{print $1}')
        secondary=$(lspci -vvv -s $bridge_bdf 2>/dev/null | grep "Bus:" | grep -oP "secondary=\K[0-9a-f]+")
        
        if [ "$secondary" = "$bus" ]; then
            echo $bridge_bdf
            return
        fi
    done
}

# 获取完整路径
echo -e "${CYAN}Building PCIe path...${NC}"
PATH_LIST=()
CURRENT=$TARGET_BDF

while [ -n "$CURRENT" ]; do
    PATH_LIST=("$CURRENT" "${PATH_LIST[@]}")
    
    # 如果在 bus 00，停止
    if echo "$CURRENT" | grep -q "^00:"; then
        break
    fi
    
    # 查找上游
    UPSTREAM=$(get_upstream_bridge $CURRENT)
    if [ -z "$UPSTREAM" ]; then
        break
    fi
    CURRENT=$UPSTREAM
done

# 显示路径
echo ""
echo -e "${GREEN}=== Complete PCIe Hierarchy ===${NC}"
echo ""

LEVEL=0
for BDF in "${PATH_LIST[@]}"; do
    INDENT=$(printf '%*s' $((LEVEL * 4)) '')
    
    # 获取设备信息
    DEV_INFO=$(lspci -s $BDF)
    DEV_NAME=$(echo "$DEV_INFO" | cut -d: -f3- | xargs)
    
    # 检查是否是桥接
    IS_BRIDGE=$(echo "$DEV_INFO" | grep -i "bridge")
    
    if [ -n "$IS_BRIDGE" ]; then
        # 桥接设备 - 显示总线信息
        BUS_INFO=$(lspci -vvv -s $BDF 2>/dev/null | grep "Bus:" | head -1)
        PRI=$(echo "$BUS_INFO" | grep -oP "primary=\K[0-9a-f]+")
        SEC=$(echo "$BUS_INFO" | grep -oP "secondary=\K[0-9a-f]+")
        SUB=$(echo "$BUS_INFO" | grep -oP "subordinate=\K[0-9a-f]+")
        
        echo -e "${INDENT}${YELLOW}┌─ Level $LEVEL: $BDF${NC}"
        echo -e "${INDENT}${YELLOW}│  $DEV_NAME${NC}"
        echo -e "${INDENT}${YELLOW}│  Primary: $PRI, Secondary: $SEC, Subordinate: $SUB${NC}"
        
        # 链路状态
        LINK_INFO=$(lspci -vvv -s $BDF 2>/dev/null | grep "LnkSta:" | head -1)
        if [ -n "$LINK_INFO" ]; then
            SPEED=$(echo "$LINK_INFO" | grep -oP "Speed \K[0-9.]+GT/s")
            WIDTH=$(echo "$LINK_INFO" | grep -oP "Width x\K[0-9]+")
            echo -e "${INDENT}${YELLOW}│  Link: ${SPEED} x${WIDTH}${NC}"
        fi
        echo -e "${INDENT}${YELLOW}└─${NC}"
        echo -e "${INDENT}   ${BLUE}│${NC}"
    else
        # 终端设备
        echo -e "${INDENT}${GREEN}┌─ Level $LEVEL: $BDF (Endpoint)${NC}"
        echo -e "${INDENT}${GREEN}│  $DEV_NAME${NC}"
        
        # 链路状态
        LINK_INFO=$(lspci -vvv -s $BDF 2>/dev/null | grep "LnkSta:" | head -1)
        if [ -n "$LINK_INFO" ]; then
            SPEED=$(echo "$LINK_INFO" | grep -oP "Speed \K[0-9.]+GT/s")
            WIDTH=$(echo "$LINK_INFO" | grep -oP "Width x\K[0-9]+")
            echo -e "${INDENT}${GREEN}│  Link: ${SPEED} x${WIDTH}${NC}"
        fi
        echo -e "${INDENT}${GREEN}└─${NC}"
    fi
    
    LEVEL=$((LEVEL + 1))
    echo ""
done

# 显示地址解析
echo ""
echo -e "${CYAN}=== Address Format Explanation ===${NC}"
echo ""
echo "Target Device: $TARGET_BDF"
echo ""
echo "Full Address: 0000:$TARGET_BDF"
echo "              ││││ ││  └─ Function: 0"
echo "              ││││ └───── Device:   0"  
echo "              │└└└─────── Bus:      0f (decimal 15)"
echo "              └────────── Domain:   0000"
echo ""

# 路径摘要
echo -e "${GREEN}=== Path Summary ===${NC}"
echo ""
FIRST_BRIDGE=${PATH_LIST[0]}
LAST_DEVICE=${PATH_LIST[-1]}

echo "Root Complex Domain: 0000 (Domain 0)"
echo "Root Complex Bus:    00 (Bus 0)"
echo "Root Port:           $FIRST_BRIDGE"
echo "Target Device:       $LAST_DEVICE"
echo "Hops:                $((${#PATH_LIST[@]} - 1))"
echo ""

# 显示完整 BDF 路径
echo -e "${BLUE}Complete BDF Path:${NC}"
for i in "${!PATH_LIST[@]}"; do
    if [ $i -eq 0 ]; then
        echo -n "0000:${PATH_LIST[$i]}"
    else
        echo -n " → 0000:${PATH_LIST[$i]}"
    fi
done
echo ""
```

运行脚本：


```bash
chmod +x analyze_pcie_path.sh
./analyze_pcie_path.sh
```

---

### 总结

### `0000:00` 的含义

- **`0000`**: PCIe Domain 0（域 0）
- **`00`**: Bus 0（总线 0，Root Complex 主总线）
- 这是整个 PCIe 树的根节点

### `0f:00.0` 的完整路径
```
0000:00:1e.0 (Root Port, Bus 0)
    ↓
0000:0d:01.0 (PCIe Switch, Bus 13)
    ↓
0000:0f:00.0 (加速卡, Bus 15)
~~~

**关键点**：

- 域始终是 `0000`（单域系统）
- 经过 2 级桥接（Root Port → Switch → Device）
- 总线号递增：`00` → `0d` → `0f`


##  查看Root Port信息

```bash
[root@localhost P2P]# lspci -nn | grep "0604"
00:09.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a49]
00:0a.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a39]
00:0b.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a39]
00:0c.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a39]
00:0d.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a49]
00:0f.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a69]
00:10.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a59]
00:1c.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c09]
00:1e.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c09]
0a:00.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c19]
0a:01.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c29]
0d:00.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c19]
0d:01.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c19]
0d:02.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c29]
0d:03.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c29]
```


### PCIe 拓扑分析

```
两张加速卡的位置：
├─ 0b:00.0  Device 2006:0100  (加速卡 1)
└─ 0f:00.0  Device 2006:0100  (加速卡 2)
```

### 上游设备信息

#### 加速卡 1 (0b:00.0)

```
完整路径：
00:1c.0 (PCIe Root Port)
  └─ 0a:00.0 (PCIe Switch Upstream Port)
      └─ 0b:00.0 (Device 2006:0100) ← 加速卡 1
```

**紧邻上游设备**: `0a:00.0` (PCIe Switch 端口)

#### 加速卡 2 (0f:00.0)

```
完整路径：
00:1e.0 (PCIe Root Port)
  └─ 0d:01.0 (PCIe Switch Downstream Port)
      └─ 0f:00.0 (Device 2006:0100) ← 加速卡 2
```

## PCIE Phy和控制器的关系
---

## PCIe PHY 和控制器的关系

### 架构层次

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (软件)                              │
│                 Device Drivers / OS                          │
└─────────────────────────────────────────────────────────────┘
                            ↕ (寄存器访问)
┌─────────────────────────────────────────────────────────────┐
│              PCIe 控制器 (Controller/Logic)                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ Ctrl 0   │  │ Ctrl 1   │  │ Ctrl 2   │  │ Ctrl 7   │   │
│  │          │  │          │  │          │  │ ...      │   │
│  │ - DMA    │  │ - DMA    │  │ - DMA    │  │          │   │
│  │ - TLP    │  │ - TLP    │  │ - TLP    │  │          │   │
│  │ - Config │  │ - Config │  │ - Config │  │          │   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
└───────┼─────────────┼─────────────┼─────────────┼─────────┘
        │             │             │             │
        └──────┬──────┴──────┬──────┴──────┬──────┘
               │             │             │
        ┌──────▼─────────────▼─────────────▼──────┐
        │         PHY 仲裁 / Lane 分配             │
        │      (Lane Mapping & Sharing)           │
        └──────┬─────────────┬─────────────────────┘
               │             │
┌──────────────▼─────────────▼─────────────────────────────────┐
│                   64-bit PCIe PHY                             │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐     │
│  │Lane 0│ │Lane 1│ │Lane 2│ │Lane 3│ │......│ │Lane63│     │
│  │      │ │      │ │      │ │      │ │      │ │      │     │
│  │ SerDes│ SerDes│ SerDes│ SerDes│ SerDes│ SerDes│         │
│  └──┬───┘ └──┬───┘ └──┬───┘ └──┬───┘ └──┬───┘ └──┬───┘     │
└─────┼────────┼────────┼────────┼────────┼────────┼─────────┘
      │        │        │        │        │        │
   TX/RX    TX/RX    TX/RX    TX/RX    TX/RX    TX/RX
      │        │        │        │        │        │
      ▼        ▼        ▼        ▼        ▼        ▼
   物理链路  物理链路  物理链路  ...     ...    物理链路
```

------

## 详细解释

### 1. PCIe PHY（物理层）

**功能**：

- **串行化/解串行化**（SerDes）：将并行数据转换为串行信号
- **电气信号处理**：驱动差分信号线，接收物理信号
- **时钟恢复**：从接收信号中恢复时钟
- **均衡和补偿**：信号完整性处理
- **编码/解码**：8b/10b（PCIe 1.0/2.0）或 128b/130b（PCIe 3.0+）

**特点**：

- **64-bit PHY** = **64 个 Lane**
- 每个 Lane 是独立的串行通道（TX + RX 差分对）
- 可以动态组合成不同宽度的链路

### 2. PCIe 控制器（逻辑层）

**功能**：

- **事务层协议**（TLP）处理
- **数据链路层**（DLL）管理
- **流量控制**和**错误检测**
- **DMA 引擎**
- **配置空间管理**
- **中断处理**

**特点**：

- 8 个控制器 = 8 个独立的 PCIe Root Port 或 Endpoint
- 每个控制器可以配置为不同的宽度（x1, x2, x4, x8, x16）

------

## 关系图解

### 资源共享模型

```
┌─────────────────────────────────────────────────────────┐
│              64 Lane PCIe PHY (共享资源池)                │
│                                                           │
│  [Lane 0-7] [Lane 8-15] [Lane 16-31] [Lane 32-63]       │
└────┬────────┬───────────┬────────────┬──────────────────┘
     │        │           │            │
     │        │           │            │
┌────▼────┐ ┌─▼─────┐ ┌──▼──────┐ ┌───▼─────────┐
│ Ctrl 0  │ │Ctrl 1 │ │ Ctrl 2  │ │  Ctrl 3-7   │
│  x8     │ │  x8   │ │  x16    │ │  (灵活配置)  │
└─────────┘ └───────┘ └─────────┘ └─────────────┘
```

### 配置示例

```
配置方案控制器 0控制器 1控制器 2控制器 3其他总 Lane 数
方案 1x16x16x16x16-64
方案 2x16x8x8x84×x464
方案 3x32x16x8x8-64
方案 4x8x8x8x84×x864
```

------

## 类比理解

### 高速公路类比

```
PCIe PHY (64 Lane)  = 64 条车道的高速公路系统
PCIe 控制器 (8个)   = 8 个收费站/出入口

示例配置：
┌──────────────────────────────────────────────────────┐
│           64 条车道（共享资源）                       │
├──────────┬──────────┬──────────┬──────────┬─────────┤
│ 收费站1  │ 收费站2  │ 收费站3  │ 收费站4  │ 收费站5-8│
│ (16车道) │ (16车道) │ (16车道) │ (8车道)  │ (8车道) │
└──────────┴──────────┴──────────┴──────────┴─────────┘
```

- **PHY** = 物理道路基础设施
- **控制器** = 管理和调度流量的出入口
- 每个控制器可以使用不同数量的车道（Lane）

------

## 动态配置示例

### Bifurcation（分叉配置）

```
情况 1: 一个 x16 控制器使用全部 16 Lane
┌─────────────────────────────────┐
│         Controller 0 (x16)       │
└─────────────────────────────────┘
│  Lane 0-15 全部分配给 Ctrl 0     │
└─────────────────────────────────┘

情况 2: 分叉为两个 x8 控制器
┌────────────────┬────────────────┐
│  Controller 0  │  Controller 1  │
│     (x8)       │     (x8)       │
└────────────────┴────────────────┘
│  Lane 0-7      │  Lane 8-15     │
└────────────────┴────────────────┘

情况 3: 分叉为四个 x4 控制器
┌──────┬──────┬──────┬──────┐
│Ctrl 0│Ctrl 1│Ctrl 2│Ctrl 3│
│ (x4) │ (x4) │ (x4) │ (x4) │
└──────┴──────┴──────┴──────┘
│ L0-3 │ L4-7 │ L8-11│L12-15│
└──────┴──────┴──────┴──────┘
```

------

## 实际应用场景

### 龙芯 7A2000 芯片示例（基于你的系统）

```
64 Lane PHY 分配：

控制器 0 (00:09.0): x4  → Lane 0-3
控制器 1 (00:0a.0): x8  → Lane 4-11   (你的 0b:00.0 加速卡)
控制器 2 (00:0b.0): x8  → Lane 12-19  (Device 1f0a:6801)
控制器 3 (00:0c.0): x8  → Lane 20-27  (Device 1f0a:6801)
控制器 4 (00:1c.0): x16 → Lane 28-43  (PCIe Switch → 2006:0100)
控制器 5 (00:1e.0): x16 → Lane 44-59  (PCIe Switch → 2006:0100)
控制器 6-7: 未使用或保留

总计：4+8+8+8+16+16 = 60 Lane (4 Lane 保留或未配置)
```

------

## 关键技术点

### 1. Lane 分配的灵活性

python

~~~python
# 伪代码：PHY Lane 分配逻辑
class PCIe_PHY:
    total_lanes = 64
    available_lanes = list(range(64))
    
    def allocate_to_controller(self, ctrl_id, width):
        """为控制器分配 Lane"""
        if len(available_lanes) >= width:
            lanes = available_lanes[:width]
            available_lanes = available_lanes[width:]
            controllers[ctrl_id].assign_lanes(lanes)
            return True
        return False

# 示例分配
allocate_to_controller(0, 16)  # Ctrl 0 使用 Lane 0-15
allocate_to_controller(1, 16)  # Ctrl 1 使用 Lane 16-31
allocate_to_controller(2, 32)  # Ctrl 2 使用 Lane 32-63
```

### 2. PHY 和控制器的协同工作
```
发送数据流程：
应用层数据
    ↓
控制器封装 TLP (事务层包)
    ↓
控制器添加 DLL 头部/CRC
    ↓
PHY 进行 8b/10b 或 128b/130b 编码
    ↓
PHY 串行化并发送到物理 Lane
    ↓
物理介质（PCB 走线或电缆）

接收数据流程（反向）
```

---

## 设计优势

### 为什么采用这种架构？

1. **灵活性**：
   - 可以根据需求动态配置 Lane 分配
   - 支持多种设备宽度（x1, x2, x4, x8, x16, x32）

2. **资源利用率**：
   - PHY 硬件成本高，共享使用更经济
   - 64 Lane 可以支持多种组合

3. **可扩展性**：
   - 8 个控制器可以连接 8 个独立设备
   - 或组合成更少的高速端口

4. **故障隔离**：
   - 每个控制器独立工作
   - 一个控制器故障不影响其他控制器

---

## 总结

### PHY 和控制器的关系

| 特性 | PCIe PHY | PCIe 控制器 |
|------|---------|------------|
| **层次** | 物理层 | 数据链路层 + 事务层 |
| **功能** | 信号传输 | 协议处理 |
| **数量** | 1 个（64 Lane） | 8 个 |
| **关系** | **共享资源池** | **资源消费者** |
| **配置** | 硬件固定 | 软件可配置 |

### 简单记忆
```
PHY = 64 条高速公路车道（硬件资源）
控制器 = 8 个收费站（管理和使用车道）

PHY 提供物理通道，控制器决定如何使用这些通道。
64 条 Lane 可以灵活分配给 8 个控制器使用。
~~~

这种架构让芯片设计既灵活又高效，可以适应不同的应用场景和性能需求。



# P2P 优化设置
---

## 背景信息
---

| 加速卡   | BDF     | 紧邻上游设备              | Root Port |
| -------- | ------- | ------------------------- | --------- |
| 加速卡 1 | 0b:00.0 | **0a:00.0** (PCIe Switch) | 00:1c.0   |
| 加速卡 2 | 0f:00.0 | **0d:01.0** (PCIe Switch) | 00:1e.0   |

两张加速卡连接到不同的 PCIe Root Port (00:1c.0 和 00:1e.0)，通过 PCIe Switch 进行连接。

当前系统上的root port信息：

```bash
[root@localhost P2P]# lspci -nn |grep "0604"
00:09.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a49]
00:0a.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a39]
00:0b.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a39]
00:0c.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a39]
00:0d.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a49]
00:0f.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a69]
00:10.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:7a59]
00:1c.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c09]
00:1e.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c09]
0a:00.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c19]
0a:01.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c29]
0d:00.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c19]
0d:01.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c19]
0d:02.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c29]
0d:03.0 PCI bridge [0604]: Loongson Technology LLC Device [0014:3c29]
```

## PCIe Relaxed Ordering (RO) 详解
---

### 什么是 Relaxed Ordering？

**Relaxed Ordering** 允许 PCIe 事务在传输过程中**不严格遵守原始发送顺序**，从而提高性能。

### 为什么需要 RO？

#### 默认情况（Strong Ordering）

```
CPU 发送 4 个写请求：
Write A → Write B → Write C → Write D

严格顺序模型：
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│  A  │ →  │  B  │ →  │  C  │ →  │  D  │
└─────┘    └─────┘    └─────┘    └─────┘
   ↓          ↓          ↓          ↓
必须等待 A 完成才能发送 B，依此类推

问题：
- 如果 A 遇到延迟，后续 B、C、D 都被阻塞

- 即使 B、C、D 可以立即处理也必须等待

- 性能受限于最慢的事务

```

#### Relaxed Ordering 模式

```
CPU 发送 4 个写请求：
Write A → Write B → Write C → Write D

放松顺序模型：
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│  A  │    │  B  │    │  C  │    │  D  │
└─┬───┘    └─┬───┘    └─┬───┘    └─┬───┘
  │          │          │          │
  └──────┬───┴──────┬───┴──────┬───┘
         ↓          ↓          ↓
     可以乱序到达（如果路径更快）
     
实际到达顺序可能是：
B → D → A → C  (根据网络拥塞情况)

优势：
✓ 避免队头阻塞 (Head-of-Line Blocking)
✓ 充分利用可用带宽
✓ 减少延迟
```

------

### Relaxed Ordering 的工作原理
---

#### TLP 头部的 RO 位

每个 PCIe 事务层包（TLP）都有一个 **Relaxed Ordering 位**：

```
TLP Header (Memory Write Request):
┌─────────────────────────────────────────────┐
│  Fmt │ Type │ TC │ Attr │ Length │ ...      │
└─────────────────────────────────────────────┘
                    ↑
                    └─ Bit 2: Relaxed Ordering (RO)
                       0 = Strong Ordering (严格顺序)
                       1 = Relaxed Ordering (允许乱序)
```

#### 顺序规则

```
事务类型RO=0 (默认)RO=1 (启用)
Write → Write必须按序可乱序
Write → Read必须按序可乱序
Read → Read可乱序可乱序
Read → Write可乱序可乱序
```

**关键点**：RO 主要影响 **Write 事务** 的顺序。
------

## 应用场景

### 适合使用 RO 的场景

1. GPU 渲染：

   - 帧缓冲区写入顺序无关紧要
   - 只要最终所有像素都写入即可

2. 网络数据包处理：

   - 数据包可以乱序到达，由上层协议重组
   - 充分利用带宽

3. 大数据传输：

   - DMA 批量传输
   - 数据块之间无依赖关系

4. AI 加速卡

   （如你的 2006:0100）：

   - 神经网络权重加载

   - 批量推理结果回写

   - 张量数据传输

### 不适合使用 RO 的场景

1. 寄存器访问：
   - 配置寄存器必须按序写入
   - 例如：先写控制寄存器，再写命令寄存器
2. 有依赖关系的操作：
   - Write A 必须在 Write B 之前完成
   - 例如：先写数据，再写触发标志
3. 强一致性要求：
   - 数据库事务
   - 文件系统元数据

## 启用RO
---

