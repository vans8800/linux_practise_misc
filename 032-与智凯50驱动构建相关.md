# 基于LS2K3000 构建智凯50驱动-腾讯元宝复盘

----



## 背景

---

本记录与智凯50适配2K3000驱动相关，主要包含gcc构建选项、智凯50驱动安装报错、多版本gcc注册等。



## 1. dummy模块[验证是否包含[GLOBAL_OFFSET_TABLE]符号

---



### 简介

`dummy.ko`是一个**虚拟网络接口驱动**。主要作用是创建一个完全由软件实现的、不与任何物理硬件绑定的网络接口（通常命名为 `dummy0`, `dummy1`等）。类似一个“虚拟的回环设备”，但它拥有自己的 IP 地址，并且能够被路由，主要用于解决特定的网络配置需求。



### 详细用途

`dummy.ko`模块本身并不处理或转发任何真实的网络数据包。其价值在于作为一个稳定的、始终“UP”（开启）的网络端点。

下面是其最典型的应用场景：

#### 1. 为没有物理连接的机器提供静态 IP 地址

这是最常见的用途。想象一台服务器，它可能：

- 是一台纯粹的虚拟机，只需要与宿主机或其他虚拟机通信，但没有虚拟网卡。
- 是一台没有物理网卡的嵌入式设备或容器。
- 其唯一的物理网卡被用于其他特殊目的（如桥接），但仍然需要一个独立的 IP 地址用于本地服务或管理。

在这种情况下，为 `dummy0`接口分配一个 IP 地址。因为这个接口是纯软件的，只要模块被加载，它就一直存在且状态为 UP，从而为主机提供了一个稳定的 IP 地址。

**示例：**

```
# 加载 dummy 模块（若尚未加载）
sudo modprobe dummy

# 创建一个 dummy 接口（现代系统通常自动创建 dummy0）
sudo ip link add dummy0 type dummy

# 为 dummy0 分配 IP 地址并启用它
sudo ip addr add 192.168.100.100/24 dev dummy0
sudo ip link set dummy0 up

# 检查接口状态
ip addr show dummy0
```

#### 2. 避免服务因网络接口宕掉而失效

某些网络服务（如 SSH 守护进程、Web 服务器、VPN 服务等）在启动时可能会绑定到一个特定的 IP 地址。若这个 IP 地址所在的物理接口因为某种原因（如网线被拔掉、驱动程序问题）变为 DOWN 状态，服务可能会停止响应或出现异常。

为了解决这个问题，可以将服务绑定到 `dummy0`的 IP 地址上。因为 `dummy0`接口永远不会因为物理连接问题而 DOWN 掉，所以服务会始终保持可达状态，大大增强了可靠性。

#### 3. 路由和策略路由的锚点

在复杂的网络设置中，尤其是在涉及**策略路由** 时，你可能需要基于源 IP 地址来决定数据包的出口。`dummy`接口为此提供了一个完美的、可控的源 IP 地址。

**示例场景：**

一台服务器有两个物理出口（`eth0`和 `eth1`）。希望所有发自本机、源 IP 为 `10.1.1.1`的流量都从 `eth1`出去。你可以：

1. 将 `10.1.1.1`分配给 `dummy0`。
2. 配置策略路由规则，指定源地址为 `10.1.1.1`的数据包使用特定的路由表。

#### 4. 网络命名空间和容器网络

在 Linux 容器（如 Docker、LXC）和网络命名空间的实现中，`dummy`接口非常有用。它可以在一个独立的网络命名空间内提供一个干净、隔离的网络端点，用于构建更复杂的虚拟网络拓扑，而无需牵扯物理设备。

#### 5. 测试和开发

对于网络协议或应用程序的开发者来说，`dummy`接口是一个理想的测试工具。可以轻松地创建一个拥有 IP 地址的虚拟接口，用于测试套接字编程、路由协议、防火墙规则等，而无需任何物理网络硬件。



###  vs  loop环回接口

- **`lo`(127.0.0.1/8)**:用途：用于**本机内部**的进程间通信。特性：发往 `lo`的流量永远不会离开主机。所有地址 127.x.x.x 都指向本机。限制：通常你不会将公网或私网IP（如 192.168.x.x）分配给 `lo`，这不符合惯例且可能造成混淆。
- **`dummy0`**:用途：作为一个**可路由的、稳定的网络端点**，它可以拥有任何你需要的 IP 地址（公网或私网）。特性：它可以像物理接口一样参与路由决策，数据包可以被路由到其他接口，或者从其他接口接收并发送到 `dummy0`。

**简单比喻**：

- `lo`就像你大脑内部的思考，不会传出身体。
- `dummy0`就像你身上的一个“虚拟口袋”，你可以从这个口袋拿东西（发送数据），也可以放东西进去（接收数据），但这个口袋本身不连接外部世界，除非你通过路由规则“伸手”到真正的口袋（物理网卡）去传递。



## 2. mon-relax 构建选项

----

### 核心摘要

`-mno-relax`是一个 GCC 选项，其作用是**指示编译器/链接器禁用“链接器松弛”优化**。

### 什么是链接器松弛？

链接器松弛 是一种非常激进的优化技术，旨在减少代码体积并提升性能。主要解决 RISC 架构（如 RISC-V）中的一个常见问题：

- **问题**：RISC 指令集通常有固定长度（如 RISC-V 的 32 位），并且指令中用于表示内存地址（如跳转目标地址、数据地址）的位域非常有限。例如，一条普通的 `jal`（跳转并链接）指令可能只能跳转到 ±1MB 的范围内。若要跳转到一个很远的地址，编译器不得不生成一个复杂的、低效的指令序列（称为“长跳转” thunk），例如：先将目标地址加载到一个寄存器。再用寄存器跳转指令。
- **松弛的解决方案**：在链接阶段，链接器已经知道所有代码和数据的最终布局与地址。链接器松弛会利用这个信息：**检查**：链接器检查那些长跳转指令。**替换**：若链接器发现某个长跳转的目标地址其实在链接后落在了单条指令的短范围内，它就会用一条更短、更快的指令（如 `jal`）来替换掉那个复杂的多指令序列。**好处**：这极大地优化了代码，使其**更小、更快**。

**简单比喻**：

想象你要去街对面的商店（短跳转），但你不知道商店具体在哪，所以你准备了一套复杂的方案：

> 先打车到市中心，再换乘地铁（长跳转方案）。但当你出门后发现商店就在眼前，你自然会选择直接走过去（松弛优化后的短跳转）。链接器就是在“链接”这个最终时刻，帮你做了这个“直接走过去”的优化决定。

------

### `-mno-relax`的作用：禁用此优化

`-mno-relax`的作用就是**关闭**这个强大的优化功能。

当使用该选项时，告诉工具链（编译器和链接器）：“**不要进行任何链接器松弛优化。请严格使用我编译时生成的指令序列，即使它很低效。**”



### 为什么要禁用优化？（使用 `-mno-relax`的场景）



既然链接器松弛如此有益，为什么还要禁用它？主要原因有以下几点：

#### a) 调试和代码稳定性

这是最常见的原因。链接器松弛会**重写指令**，这可能导致：

- **调试信息错乱**：在调试器（如 GDB）中，源代码的行号、单步执行可能与优化后的指令流不匹配，给调试带来巨大困难。
- **代码地址变化**：指令被替换后，其长度和地址都可能改变，这可能影响某些对地址有严格依赖的代码（例如某些低级引导程序或手写的汇编代码）。

禁用松弛可以确保生成的机器码与编译时预期的完全一致，使得调试过程可预测和稳定。

#### b) 与某些工具或引导程序的兼容性

在一些非常底层的开发中，如编写 Bootloader（引导程序）或操作系统内核，代码的执行流程和内存布局有极其严格的要求。链接器松弛可能会改变指令，从而意外地破坏这些精细的设定。为了确保 100% 的控制，开发者会选择禁用这个优化。

#### c) 工具链的 Bug

在 RISC-V 工具链的早期阶段，链接器松弛功能可能包含一些未发现或未修复的 Bug。若在使用优化时遇到了奇怪的问题（如程序崩溃、错误跳转），一个有效的排查步骤就是使用 `-mno-relax`来禁用优化，看看问题是否消失。若问题消失，那么很可能是松弛优化本身或与之相关的工具链部分存在 Bug。

#### d) 指令集的精确性（较少见）

某些学术或研究场景下，开发者可能需要精确控制生成的指令序列，以进行性能分析或架构研究。此时，禁用不可预测的优化是必要的。

------

### 总结对比

| 特性         | 启用链接器松弛（默认）             | 使用 `-mno-relax`（禁用松弛）            |
| :----------- | :--------------------------------- | :--------------------------------------- |
| **目标**     | **性能与代码大小优化**             | **代码稳定性、可预测性与可调试性**       |
| **工作原理** | 链接时用短指令替换低效的长跳转序列 | 严格保留编译时生成的指令序列             |
| **结果**     | 代码更小、更快                     | 代码更大、可能更慢，但与编译预期完全一致 |
| **适用场景** | 发布版本、性能敏感型应用           | 调试阶段、底层系统开发、排查工具链问题   |

**如何使用：**

直接在编译命令中加上该选项即可，它需要传递给链接器。

```
# 编译时禁用链接器松弛
riscv64-unknown-elf-gcc -mno-relax -o my_program my_program.c

# 或者针对汇编文件
riscv64-unknown-elf-gcc -mno-relax -c my_assembly.s
```

总之，`-mno-relax`是 RISC-V 开发中的一个重要“安全开关”，在你需要绝对控制代码生成或遇到棘手问题时，它是一个非常有用的工具。



## 3. 多版本GCC注册

---



### 简介

----

`update-alternatives`是 Debian/Ubuntu 系统中管理多个软件版本的工具。下面是使用它来注册不同目录下 GCC 的详细步骤：



### 多版本编译器注册

----



  #### 检查当前已注册的 GCC 版本

```
# 查看当前可用的 GCC 替代项
sudo update-alternatives --config gcc

# 或者查看所有已注册的编译器
sudo update-alternatives --list gcc
```



#### 注册不同目录下的 GCC

假设你有两个不同版本的 GCC：

- `/usr/bin/gcc-9`(系统自带的 GCC 9)
- `/opt/gcc-11.2.0/bin/gcc`(手动安装的 GCC 11.2.0)

#### 注册第一个 GCC 版本：

```
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 \
    --slave /usr/bin/g++ g++ /usr/bin/g++-9 \
    --slave /usr/bin/gcov gcov /usr/bin/gcov-9 \
    --slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-9 \
    --slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-9 \
    --slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-9
```

#### 注册第二个 GCC 版本：

```
sudo update-alternatives --install /usr/bin/gcc gcc /opt/gcc-11.2.0/bin/gcc 110 \
    --slave /usr/bin/g++ g++ /opt/gcc-11.2.0/bin/g++ \
    --slave /usr/bin/gcov gcov /opt/gcc-11.2.0/bin/gcov \
    --slave /usr/bin/gcc-ar gcc-ar /opt/gcc-11.2.0/bin/gcc-ar \
    --slave /usr/bin/gcc-nm gcc-nm /opt/gcc-11.2.0/bin/gcc-nm \
    --slave /usr/bin/gcc-ranlib gcc-ranlib /opt/gcc-11.2.0/bin/gcc-ranlib
```

####  参数详解

- `--install <链接> <名称> <路径> <优先级>`

  `<链接>`: 创建的符号链接路径（如 `/usr/bin/gcc`）

  `<名称>`: 替代组的名称（如 `gcc`）

  `<路径>`: 实际可执行文件的路径

  `<优先级>`: 数字越大优先级越高，自动模式会选择优先级最高的

  

- `--slave <从链接> <从名称> <从路径>`当主程序切换时，从属程序也会自动切换确保 gcc/g++/gcov 等工具版本一致



### 查看和管理已注册的版本

---



```
sudo update-alternatives --config gcc
```

输出示例：

```
有 2 个候选项可用于替换 gcc (提供 /usr/bin/gcc)。

  选择       路径                       优先级  状态
------------------------------------------------------------
* 0            /usr/bin/gcc-9             90        自动模式
  1            /opt/gcc-11.2.0/bin/gcc   110        手动模式
  2            /usr/bin/gcc-9             90        手动模式

按 <回车> 保留当前选择[*]，或者输入选择编号：
```



#### 切换 GCC 版本：

```
# 交互式切换
sudo update-alternatives --config gcc

# 或者直接指定编号
sudo update-alternatives --set gcc /opt/gcc-11.2.0/bin/gcc
```



### 验证切换结果

-----



```
# 检查当前使用的 GCC 版本
gcc --version
which gcc

# 检查相关的工具链是否同步切换
g++ --version
gcov --version
```



### 删除已注册的版本

----

```bash
*# 从替代列表中移除某个版本* 
sudo update-alternatives --remove gcc /opt/gcc-11.2.0/bin/gcc 

*# 完全移除整个替代组（慎用）* 
sudo update-alternatives --remove-all gcc
```



## 4. Debian 系统构建内核

----



```bash
apt source linux下载的源码包使用方法
apt build-dep linux  ##安装源码包编译所需依赖
dpkg-buildpackage -us -uc -b #开始编译
```



### 参数含义详解

#### `-us`：不签名源码包

```
-us, --unsigned-source
```

- **作用**：跳过对生成的 `.dsc`（源码包描述文件）的 GPG 签名

- **使用场景**：本地测试构建、内部使用，不需要官方发布

- **示例**：构建的包文件不会包含 `.changes.asc`或 `.dsc.asc`签名文件

  

#### `-uc`：不签名 changes 文件

```
-uc, --unsigned-changes
```

- **作用**：跳过对 `.changes`文件的 GPG 签名
- **使用场景**：与 `-us`配合使用，用于非正式构建
- **示例**：生成的 `.changes`文件不会被数字签名

#### `-b`：仅构建二进制包

```
-b, --build=binary
```

- **作用**：只构建二进制包，不构建源码包
- **使用场景**：当只需要二进制包，不需要重新分发源码时
- **效果**：不会生成 `.orig.tar.gz`, `.debian.tar.gz`, `.dsc`等源码相关文件只生成 `.deb`二进制包文件构建速度更快，占用空间更小



### 其他常用参数

----

## 

| 参数  | 全称                 | 作用                | 使用场景 |
| :---- | :------------------- | :------------------ | :------- |
| `-us` | `--unsigned-source`  | 不签名源码包        | 本地测试 |
| `-uc` | `--unsigned-changes` | 不签名 changes 文件 | 本地测试 |
| `-b`  | `--build=binary`     | 仅构建二进制包      | 快速构建 |
| `-S`  | `--build=source`     | 仅构建源码包        | 源码分发 |
| `-nc` | `--no-pre-clean`     | 不预先清理          | 增量构建 |
| `-tc` | `--clean`            | 构建后清理          | 节省空间 |



## 5. Debian推荐包

----



推荐的包"（Recommended packages）是 Debian/Ubuntu 包管理系统中的一个重要概念。让

### 三个依赖级别

----



Debian 包管理系统将依赖关系分为三个层次：

| 依赖类型               | 强制性     | 默认安装     | 用途说明                     |
| :--------------------- | :--------- | :----------- | :--------------------------- |
| **Depends**（依赖）    | **强制**   | 是           | 软件运行必需，缺少则无法工作 |
| **Recommends**（推荐） | **非强制** | 是（可禁用） | 增强功能，提供更好体验       |
| **Suggests**（建议）   | **可选**   | 否           | 额外功能，按需安装           |



### 具体示例分析

---



#### 示例1：文本编辑器 vim

```
# 查看 vim 的依赖关系
apt-cache depends vim

# 输出示例：
Depends: vim-common (= 2:8.2.3995-1ubuntu2)
Depends: vim-runtime (= 2:8.2.3995-1ubuntu2)
Depends: libc6 (>= 2.34)
Recommends: fonts-dejavu-core
Recommends: gvim
Recommends: vim-doc
Suggests: ctags
Suggests: vim-scripts
```

**分析**：

- **Depends**：`vim-common`, `vim-runtime`, `libc6`- 没有这些 vim 无法运行
- **Recommends**：`fonts-dejavu-core`（字体）, `gvim`（图形界面）, `vim-doc`（文档）- 增强体验但不是必需
- **Suggests**：`ctags`, `vim-scripts`- 额外功能，用户按需选择

