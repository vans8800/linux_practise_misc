# QT 界面与业务逻辑分离

Qt 开发的一个核心理念：UI 归 UI，逻辑归逻辑，别混在一起写。优点如下：

- 改界面不怕把业务搞崩，反过来也一样
- UI 和逻辑能分头开发，效率翻倍
- 业务逻辑可以单独写单元测试
- 界面组件能复用，换肤也容易



## 基本架构

一个典型的程序一般包含两个核心模块：

| 模块                   | 职责                   |
| ---------------------- | ---------------------- |
| **用户界面模块（UI）** | 接收用户输入、展示数据 |
| **业务逻辑模块**       | 根据用户需求处理数据   |

这两块必须解耦，不能让界面代码直接调业务逻辑，也不能让业务逻辑去操作界面控件。

## 设计原则

**强内聚、弱耦合**，这六个字要刻脑子里：

- 单一职责：每个模块只干一件事

- 模块组成：模块内部的子模块只为整体的单一功能服务

- 交互规则：模块之间通过约定好的接口交互

- 单向依赖：A 依赖 B 可以，但 A 和 B 互相依赖就是设计问题

> 循环依赖是糟糕设计的典型标志之一，必须避免。

### 什么是接口？

- 广义上：接口是模块之间的一种”契约”

- C++ 中：通常是只包含公开纯虚函数的抽象类

- 实现原则：必须有模块实现对应的接口

## Qt 开发的三种模式

根据项目需求，常见的开发模式有三种：

### 1. 纯代码模式

用 `QWidget` 纯手写界面，QSS 做样式，C++ 写逻辑。

**优点**：灵活，啥都能控制

**缺点**：代码量大，改起来累

### 2. Qt Designer 模式

拖控件画界面（类似 MFC），生成 `.ui` 文件，QSS 美化，C++ 写逻辑。

这是现在大部分公司的选择，开发效率高，上手也快。

### 3. QML 混合模式

QML 做 UI、JavaScript 写交互、C++ 写后台，三种语言混合。

适合做现代化、动效多的界面，现在用的越来越多。

## 分离的核心方法

### 1. 信号与槽

Qt 的招牌机制，天然适合做解耦。

界面只管发信号：用户点了按钮、输入了文字，逻辑层连上槽函数处理。两边不直接调用，通过信号槽沟通。

```c++
// 界面发信号
emit calculateClicked(expression);

// 逻辑层连接
connect(ui, &CalcUI::calculateClicked, this, &CalcLogic::doCalculate);
```

信号槽还支持跨线程，做异步操作很方便。

### 2. MVC 模式

经典的三层拆分，Qt 官方也推荐：

| 角色       | 职责           | Qt 中的体现               |
| ---------- | -------------- | ------------------------- |
| Model      | 数据和业务逻辑 | `QAbstractListModel`      |
| View       | 界面展示       | `QListView`、`QTableView` |
| Controller | 协调 M 和 V    | 信号槽连接                |

Model 不知道 View 的存在，只管处理数据。View 接收 Model 的更新并展示。Controller 处理用户输入，协调两边。

**例子**：Model 提供数据列表，View 用 `QListView` 显示，Controller 处理点击事件。

```c++
// Model：提供数据
class MyModel : public QAbstractListModel {
    QStringList m_items;
public:
    void addItem(const QString &item){
        beginInsertRows(QModelIndex(), rowCount(), rowCount());
       	m_items.append(item);
        endInsertRows();
     }
    
    int rowCount(const QModelIndex &parent = QModelIndex())const override{
    	return m_items.count();
    }
    
	QVariant data(const QModelIndex &index, int role)const override{
        if (role == Qt::DisplayRole)
        	return m_items[index.row()];
        return QVariant();
    }
};

// View：展示界面
class MyView : public QWidget {
    QListView *m_listView;
public:
    MyView() : m_listView(new QListView(this)) {
            QVBoxLayout *layout = new QVBoxLayout(this);
            layout->addWidget(m_listView);
    }
    
    void setModel(QAbstractItemModel *model){
            m_listView->setModel(model);
    }
};

// 组装使用
MyModel model;
model.addItem("Item 1");
model.addItem("Item 2");

MyView view;
view.setModel(&model);
view.show();
```

### 3. 接口抽象

给业务逻辑定一个纯虚接口，界面只依赖接口，不管具体实现。

```c++
// 接口定义
classI Calculator {
public:
    virtual bool expression(const QString& exp)= 0;
    virtual QString result()= 0;
    virtual ~ICalculator() = default;
};

// 界面类只认接口
class CalcUI {
    ICalculator* m_logic;
public:
    void setLogic(ICalculator* logic){ m_logic = logic; }
    void onButtonClick(){
            m_logic->expression("1+1");
            qDebug() << m_logic->result();
        }
};
```

好处：换逻辑实现不用改界面代码。

### 4. 继承封装

最基础的做法：自定义窗口类继承 `QWidget`，界面初始化封装成 `initUI()` 方法，业务逻辑放另一个类。

```c++
class MyWindow : public QWidget {
public:
    MyWindow(QWidget* parent = nullptr) : QWidget(parent) {
        initUI();
    }
    
private:
	void initUI();  // 只管界面
};
```

### 5. QSS 样式分离

样式代码（颜色、字体、边框等）写到单独的 `.qss` 文件，程序运行时加载。

```C++
QFile file(":/styles/dark.qss");
file.open(QFile::ReadOnly);
qApp->setStyleSheet(file.readAll());
```

换肤只要换加载的文件，代码不用动。

## 完整示例：计算器

把上面的方法组合起来，一个典型的四层架构：

```C++
ICalculator          -- 接口层：定义计算核心的抽象接口
    ↑
QCalculatorDec       -- 逻辑层：实现 ICalculator，负责具体运算
    ↑
QCalculatorUI        -- 界面层：依赖 ICalculator 接口执行计算任务
    ↑
QCalculator          -- 组装层：把 UI 和逻辑拼接在一起
```

### 接口层

```c++
classI Calculator {
public:
    virtualboolexpression(const QString& exp)= 0;
    virtual QString result()= 0;
};
```

### 逻辑层

```C++
class QCalculatorDec : public ICalculator {
    QString m_result;
public:
    bool expression(const QString& exp) override{
            // 解析表达式、计算...
            m_result = "42";
            return true;
    }
    QString result()override{ return m_result; }
};
```

### 界面层

```c++
class QCalculatorUI : public QWidget {
    ICalculator* m_calc;
public:
    void setCalculator(ICalculator* calc){ m_calc = calc; }

    void onCalculate(){
    if (m_calc->expression(m_input->text())) {
                m_output->setText(m_calc->result());
            }
        }
};
```

### 组装层

```C++
class QCalculator {
protected:
    QCalculatorUI* m_ui;
    QCalculatorDec m_cal;  // 计算逻辑模块
public:
    static QCalculator* NewInstance();
    voidshow(){ m_ui->show(); }
    ~QCalculator() { delete m_ui; }
};
```

界面层只知道接口是什么样的，不关心计算怎么实现。

逻辑层专心处理算法，不管按钮长什么样。组装层负责把两边拼起来。

## 小结

- 模块之间的交互必须通过接口完成

- 接口是模块间的”契约”

- 单向依赖，杜绝循环依赖

- 始终坚持”强内聚、弱耦合”的设计原则
